
JavaScript是运行于单线程的环境中，而定时器仅仅是计划代码在未来的某个时间执行。

定时器队列的工作方式是，当特定时间过去后将代码插入。注意，给队列添加代码并不意味着对它立刻执行，而只能表示它会尽快执行。设定一个150ms后执行的定时器不代表到了150ms代码就立刻执行，它表示代码会在150ms后被加入到队列。如果这个时间点上，队列中没有其他东西，那么这段代码就会被执行，表面上看好像代码在精确指定的时间点上执行了。

> 关于定时器要记住的最重要的事情是，指定的时间间隔表示何时将定时器的代码添加到队列，而不是何时实际执行代码。

实际上Firefox中定时器的实现还能让你确定定时器过了多久才执行，这需传递一个实际执行的时间与间隔的差值。如下面的例子所示。

    //仅在Firefox中
    setTimeout(function(diff){
    	if(diff>0){
    		//晚调用
    	}else if(diff<0){
    		//早调用
    	}else{
    		//调用即使
    	}
    },250)
    

执行完一套代码后，JavaScript进程返回一段很短的事件，这样页面上的其他处理就可以进行了。

### 22.3.1 重复的定时器

使用setInterval()创建的定时器确保了定时器代码规则地插入队列中。这个方式的问题在于，定时器代码可能在代码再次被添加到队列之前还没有完成执行，结果导致定时器代码连续运行好几次，而之间没有任何停顿。

幸好，JavaScript引擎够聪明，能避免这个问题。当使用setInterval()时，仅当没有该定时器的任何其他代码实例时，才将定时器代码添加到队列中。这确保了定时器代码加入的队列中的最小时间间隔为指定间隔。

这种重复定时器的规则有两个问题：（1）某些间隔会被跳过；（2）多个定时器的代码执行之间的间隔可能会比预期小。

> 详见书籍


为了避免setInterval()的重复定时器的这两个缺点，你可以用如下模式使用链式setTimeout()调用。

    setTimeout(functio(){
    	//处理中
    	setTimeout(arguments.callee, interval);
    }, interval)

这个模式链式调用了setTimeout()，每次函数执行的时候都会创建一个新的定时器。第二个setTimeout()调用使用了arguments.callee来获取对当前执行的函数的引用，并为其设置另外一个定时器。这样做的好处是，在前一个定时器代码执行完之前，不会向队列插入新的定时器代码，确保不会有任何缺失的间隔。而且，它可以保证在下一次定时器代码执行之前，至少要等待指定的间隔，避免了连续的运行。

    setTimeout(function(){
      var div = document.getElementById("myDiv");
      left = parseInt(div.style.left) + 5;
      div.style.left = left + "px";
      if(left < 200){
    	setTimeout(arguments.callee, 50)
      }
    }, 50)

这段定时器代码每次执行的时候将一个<div>元素向左移动，当左坐标在200像素的时候停止。JavaScript动画中使用这个模式很常见。