## 21.5 其他跨域技术

在CORS出现以前，要实现跨域Ajax通信颇费周折。开发人员相了一些办法，利用DOM中能够执行跨域请求的功能，在不依赖XHR对象的情况下也能发送某种请求。虽然CORS技术已经无处不在，但开发人员自己发明的这些技术仍然被广泛利用，毕竟这样不需要修改服务器端代码。


### 21.5.1 图像Ping

上述第一种跨域请求技术是使用<img>标签。我们知道，一个网页可以从任何网页中加载图像，不用担心跨域不跨域。这也是在线广告跟踪浏览量的主要方式。正如第13张讨论过的，也可以动态地地建图像，使用它们的onload和onerror事件处理程序来确定是否接收到了响应。

动态创建图像经常用于图像Ping。图片Ping是与服务器进行简单、单向的跨域通信的一种方式。请求的数据是通过查询字符串形式发送的，而响应可以是任意内容，但通常是像素图或204响应。通过图像Ping，浏览器得不到任何具体的数据，但是通过侦听load和error事件，它能知道响应时什么时候接收到的。来看下面的例子。

    var img = new Image();
    img.onload = img.onerror = function(){
    	alert("Done!")
    }
    img.src = "http://www.example.com/test?name=Nicholas";

这里创建了一个Image的实例，然后将onload和onerror事件处理程序指定为同一个函数。这样无论是什么响应，只要请求完成，就能得到通知。请求从设置src属性那一刻开始，而这个例子在请求中发送了一个name参数。

图像Ping最常用于跟踪用户点击页面或动态广告曝光次数。图像Ping有两个主要的缺点，一是只能发送GET请求，二十无法访问服务器的响应文本。因此，图像Ping只能用于浏览器与服务器间的单向通信。

### 21.5.2 JSONP

JSONP是JSON with padding（填充式JSON或参数式JSON）的简写，是应用JSON的一种新方法，在后来的Web服务中非常流行。JSONP看起来与JSON差不多，只不过是被包含在函数调用中的JSON,就像下面这样。
    
    callback({ "name": "Nicholas"})

JSONP由两部分组件：回调函数和数据。回调函数式当响应到来时应该再页面中调用的函数。回调函数的名字一般是在请求中指定的。而数据就是传入回调函数中的JSON数据。下面是一个典型的JSONP请求。

    http://freegeoip.net/json/?callback=handleResponse

这个URL是在请求一个JSONP地理定位服务。通过查询字符串来指定JSONP服务的回调参数是很常见的，就像上面的URL所示，这里指定的回调函数的名字叫handleResponse()。

JSONP是通过动态`<script>`元素（要了解详细信息，请参考第13章）来使用的，使用时可以为src属性指定一个跨域URL。这里的`<script>`元素与<img>元素蕾西，都有能力不受限制地从其他域加载资源。因为JSONP是有效的JavaScript代码，所以才请求完成后，既在JSONP响应加载到页面中以后，就会立即执行。来看一个例子。

    function handleResponst(response){
    	alert("You're at IP address" + response.ip + ", which is in "+ response.city+" ,"+ response.region_name);
    }
    var script = document.createElement("script")
    script.src = "http://freegeoip.net/json/?callback=handleResponse";
    document.body.insertBefore(script, document.body.firstChild)


这个例子通过查询地理定位服务来显示你的IP地址和位置信息。
JSONP之所以在开发人员中极为流行，主要原因是它非常简单易用。与图像Ping相比，它的优点在于能够直接访问响应文本，支持在浏览器与服务器直接的双向通信。不过，JSONP也有两点不足。

首先，JSONP是从其他域中加载代码执行。如果其他域不安全，很可能会在响应夹带一些恶意代码，而此时除了完全放弃JSONP调用之外，没有办法追究。因此在使用不是你自己运维的web服务时，一定得保证它安全可靠。

其次，要确定JSONP请求是否失败并不容易。虽然HTML5给`<script>`元素新增了一个onerror事件处理程序，但目前没有得到任何浏览器支持。为此，开发人员不得不使用计时器检测指定时间内是否接收到了响应。但就算这样也不能尽如人意，毕竟不是每个用户上网的速度和带宽都一样。

### 21.5.3 Comet

Comet是Alex Russell 发明的一个词儿，指的是一种更高级的Ajax技术（经常有人称为“服务器推送”）。Ajax是一种从页面向服务器请求数据的技术，而Comet则是一种服务器向页面推送数据的技术。Comet能够让信息几乎实时地被推送到页面上，非常适合处理体育比赛的分数和股票报价。

有两种实现Comet的方式:**长轮询和流**。长轮询是传统轮询（也成为短轮询）的一个翻版，既浏览器定时向服务器发送请求，看有没有更新的数据。

长轮询是把短轮询颠倒了一下。页面发起一个到服务器的请求，然后服务器一直保持连接打开，直到有数据可发送。发送完数据之后，浏览器关闭连接，随机又发起一个到服务器的新请求。这一过程在页面打开期间一直持续不断。

无论是长轮询还短轮询，浏览器都要在接收数据之前，先发起对服务器的连接。两者最大的区别在于服务器如何发送数据。短轮询是服务器立即发送响应，无论数据是否有效，而长轮询是等待发送响应。轮询的优势是所有浏览器都支持，因此使用XHR对象和setTimeout()就能实现。而你要做的就是决定什么时候发送请求。

第二种流星的Comet实现是HTTP流。流不同于上述两种轮询，因为它在页面的整个生命周期内只使用一个HTTP连接。具体来说，就是浏览器想服务器发送一个请求，而服务器保持连接打开，然后周期性地向浏览器发送数据。比如，下面这段PHP脚本就是采用流实现的服务器中常见的形式。

    <?php
    	$i = 0;
    	while(true){
    		//输出一些数据，然后立即刷新输出缓存
    		echo "Number is $i";
    		flush;
    		sleep(10);//等几秒钟
    		$i++;
    	}
    
    
所有服务器端语言都支持打印到输出缓存然后刷新（将输出缓存中的内容一次性全部发送到客户端）的功能。而这正是实现HTTP流的关键所在。


在Firefox、Safri、Opera和Chrome中，通过侦听readystatechange事件及检测readyState的值是否为3，就可以利用XHR对象实现HTTP流。在上述这些浏览器中，随着不断从服务器接收数据，readyState的值会周期性的变为3。当readyState值变为3时，responseText属性中就会报错接收到的所有数据。此时，就需要比较此前接收到的数据，决定从什么位置开始取得最新的数据。使用XHR对象实现HTTP流的典型代码如下所示。

    function createStreamingClient(url, progress, finished){
      var xhr = new XMLHttpRequest(),
      received = 0;
      xhr.open("get", url, true);
      xhr.onreadystatechange = function() {
	    var result;
	    if(xhr.readyState ==3 ){
	      //只取得最新数据并调整计数器
	      result = xhr.responseText.substring(received);
	      received += result.length;
	    }else if(xhr.readyStae == 4){
	      finished(xhr.responseText)
	    }
      };
      xhr.send(null);
      return xhr;
    }
    
    var client = createStreamingClient("streaming.php", function(data){
	      alert("Received: "+CharacterData)
	    }, function(data){
	      alert("Done!")
    })
    

这个createStreamingClient()函数接收三个参数：要链接的URL、在接收到数据时调用的函数以及关闭连接时调用的函数。有时候，当连接关闭时，很可能还需要重新建立，所以关注连接什么时候关闭还是很有必要的。

只要readystatechange事件发生，而且readtState值为3，就对responseText进行分割以取得最新数据。这里的received变量用于记录已经处理了多少个字符，每次readyState值为3时都递增。然后，通过progress回调函数来处理传入的新数据。而当readyState值为4时，则只需finished回调函数，传入响应返回的全部内容。

虽然这个例子比较简单，而且也能在大多数浏览器正常运行（ie除外），但管理Comet的连接时很容易出错的，需要时间不断改进才能达到完美。浏览器社区认为Comet是未来Web一个重要组件部分，为了简化这一技术，又为Comet创建了两个新的接口